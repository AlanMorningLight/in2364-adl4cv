{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# GCN for DAVIS 2016\n",
    "\n",
    "In this notebook, a custom [PyTorch Geometric](https://rusty1s.github.io/pytorch_geometric/build/html/index.html) [InMemoryDataset](https://rusty1s.github.io/pytorch_geometric/build/html/_modules/torch_geometric/data/in_memory_dataset.html#InMemoryDataset) for the DAVIS 2016 dataset is created. The implementation is based on this [tutorial](https://rusty1s.github.io/pytorch_geometric/build/html/notes/create_dataset.html). The dataset is then used to train a simple GCN network as a first evaluation based on this [tutorial](https://rusty1s.github.io/pytorch_geometric/build/html/notes/introduction.html#learning-methods-on-graphs).\n",
    "\n",
    "The dataset consists of single PyTorch Geometric [Data](https://rusty1s.github.io/pytorch_geometric/build/html/_modules/torch_geometric/data/data.html#Data) objects which model a single graph with various attributes. For this dataset, a graph for each contour is created. Hereby, each node of the graph represents one contour point. The feature of each node is the OSVOS feature vector from the next frame at this point. Each node is connected to its K nearest neighbours. The feature of each edge is the distance between the nodes it connects. The targets of each node is the translation it undergoes from the current to the next frame."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Imports"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import cv2\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "\n",
    "import torch\n",
    "import torch.nn.functional as F\n",
    "import torch.nn as nn\n",
    "import torch.optim as optim\n",
    "from torch.utils.data.sampler import SequentialSampler\n",
    "\n",
    "from torch_geometric.nn import GCNConv\n",
    "from torch_geometric.data import DataLoader\n",
    "\n",
    "from pg_datasets.davis_2016 import DAVIS2016\n",
    "\n",
    "# for auto-reloading extenrnal modules\n",
    "# see http://stackoverflow.com/questions/1907993/autoreload-of-modules-in-ipython\n",
    "%load_ext autoreload\n",
    "%autoreload 2\n",
    "\n",
    "device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Paths & Constants"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "PYTORCH_GEOMETRIC_DAVIS_2016_DATASET_PATH = 'pg_datasets/DAVIS_2016'\n",
    "CONTOURS_FOLDERS_PATH = 'DAVIS_2016/DAVIS/Contours/480p'\n",
    "IMAGES_FOLDERS_PATH = 'DAVIS_2016/DAVIS/JPEGImages/480p'\n",
    "TRANSLATIONS_FOLDERS_PATH = 'DAVIS_2016/DAVIS/Translations/480p'\n",
    "\n",
    "LAYER = 4\n",
    "K = 32\n",
    "\n",
    "SKIP_SEQUENCES = ['bmx-trees', 'bus', 'cows', 'dog-agility', 'horsejump-high', \n",
    "                  'horsejump-low', 'kite-walk', 'lucia', 'libby', 'motorbike',\n",
    "                  'paragliding', 'rhino', 'scooter-gray', 'swing']\n",
    "\n",
    "TRAIN_SEQUENCES = ['bear', 'bmx-bumps', 'boat', 'breakdance-flare', 'bus', \n",
    "                   'car-turn', 'dance-jump', 'dog-agility', 'drift-turn', \n",
    "                   'elephant', 'flamingo', 'hike', 'hockey', 'horsejump-low', \n",
    "                   'kite-walk', 'lucia', 'mallard-fly', 'mallard-water', \n",
    "                   'motocross-bumps', 'motorbike', 'paragliding', 'rhino', \n",
    "                   'rollerblade', 'scooter-gray', 'soccerball', 'stroller',\n",
    "                   'surf', 'swing', 'tennis', 'train']\n",
    "\n",
    "VAL_SEQUENCES = ['blackswan', 'bmx-trees', 'breakdance', 'camel', 'car-roundabout',\n",
    "                 'car-shadow', 'cows', 'dance-twirl', 'dog', 'drift-chicane', \n",
    "                 'drift-straight', 'goat', 'horsejump-high', 'kite-surf', 'libby', \n",
    "                 'motocross-jump', 'paragliding-launch', 'parkour', 'scooter-black', \n",
    "                 'soapbox']\n",
    "\n",
    "BATCH_SIZE = 1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Train and Val Dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Processing...\n",
      "#0: bear\n",
      "Start online training...\n",
      "Model not existent --> Training\n",
      "Finished online training...\n",
      "Create new OSVOS model...\n",
      "Constructing OSVOS architecture..\n",
      "Initializing weights..\n"
     ]
    },
    {
     "ename": "FileNotFoundError",
     "evalue": "[Errno 2] No such file or directory: '/home/maximilian_boemer/in2364-adl4cv/OSVOS_PyTorch/models/bear_epoch-500.pth'",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-15-839c4c932b9f>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m      3\u001b[0m                   \u001b[0mLAYER\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mK\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      4\u001b[0m                   \u001b[0mSKIP_SEQUENCES\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mTRAIN_SEQUENCES\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mVAL_SEQUENCES\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 5\u001b[0;31m                   train=True)\n\u001b[0m",
      "\u001b[0;32m~/in2364-adl4cv/pg_datasets/davis_2016.py\u001b[0m in \u001b[0;36m__init__\u001b[0;34m(self, root, contours_folders_path, images_folders_path, translations_folders_path, layer, k, skip_sequences, train_sequences, val_sequences, train, transform, pre_transform)\u001b[0m\n\u001b[1;32m     35\u001b[0m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mtrain\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mtrain\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     36\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 37\u001b[0;31m         \u001b[0msuper\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mDAVIS2016\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__init__\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mroot\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtransform\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mpre_transform\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     38\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     39\u001b[0m     \u001b[0;34m@\u001b[0m\u001b[0mproperty\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/.local/lib/python3.7/site-packages/torch_geometric/data/dataset.py\u001b[0m in \u001b[0;36m__init__\u001b[0;34m(self, root, transform, pre_transform, pre_filter)\u001b[0m\n\u001b[1;32m     81\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     82\u001b[0m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_download\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 83\u001b[0;31m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_process\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     84\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     85\u001b[0m     \u001b[0;34m@\u001b[0m\u001b[0mproperty\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/.local/lib/python3.7/site-packages/torch_geometric/data/dataset.py\u001b[0m in \u001b[0;36m_process\u001b[0;34m(self)\u001b[0m\n\u001b[1;32m    115\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    116\u001b[0m         \u001b[0mmakedirs\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mprocessed_dir\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 117\u001b[0;31m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mprocess\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    118\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    119\u001b[0m         \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'Done!'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/in2364-adl4cv/pg_datasets/davis_2016.py\u001b[0m in \u001b[0;36mprocess\u001b[0;34m(self)\u001b[0m\n\u001b[1;32m    169\u001b[0m             \u001b[0;31m# Create OSVOS model for feature vector extraction\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    170\u001b[0m             \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'Create new OSVOS model...'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 171\u001b[0;31m             \u001b[0mnew_model\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_create_osvos_model\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mmodel_path\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mlayer\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    172\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    173\u001b[0m             \u001b[0;31m# Get list of translations (one for each frame in the sequence)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/in2364-adl4cv/pg_datasets/davis_2016.py\u001b[0m in \u001b[0;36m_create_osvos_model\u001b[0;34m(self, model_path, layer)\u001b[0m\n\u001b[1;32m    107\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    108\u001b[0m         \u001b[0mmodel\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mvo\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mOSVOS\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mpretrained\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 109\u001b[0;31m         \u001b[0mmodel\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mload_state_dict\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtorch\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mload\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mmodel_path\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmap_location\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mlambda\u001b[0m \u001b[0mstorage\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mloc\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mstorage\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    110\u001b[0m         \u001b[0mmodel\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0meval\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    111\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/opt/anaconda3/lib/python3.7/site-packages/torch/serialization.py\u001b[0m in \u001b[0;36mload\u001b[0;34m(f, map_location, pickle_module, **pickle_load_args)\u001b[0m\n\u001b[1;32m    380\u001b[0m             \u001b[0;34m(\u001b[0m\u001b[0msys\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mversion_info\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0;36m2\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0misinstance\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mf\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0municode\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    381\u001b[0m         \u001b[0mnew_fd\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mTrue\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 382\u001b[0;31m         \u001b[0mf\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mopen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mf\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m'rb'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    383\u001b[0m     \u001b[0;32melif\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0msys\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mversion_info\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0;36m3\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0misinstance\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mf\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mpathlib\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mPath\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    384\u001b[0m         \u001b[0mnew_fd\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mTrue\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] No such file or directory: '/home/maximilian_boemer/in2364-adl4cv/OSVOS_PyTorch/models/bear_epoch-500.pth'"
     ]
    }
   ],
   "source": [
    "train = DAVIS2016(PYTORCH_GEOMETRIC_DAVIS_2016_DATASET_PATH, \n",
    "                  CONTOURS_FOLDERS_PATH, IMAGES_FOLDERS_PATH, TRANSLATIONS_FOLDERS_PATH, \n",
    "                  LAYER, K, \n",
    "                  SKIP_SEQUENCES, TRAIN_SEQUENCES, VAL_SEQUENCES,\n",
    "                  train=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "val = DAVIS2016(PYTORCH_GEOMETRIC_DAVIS_2016_DATASET_PATH, \n",
    "                CONTOURS_FOLDERS_PATH, IMAGES_FOLDERS_PATH, TRANSLATIONS_FOLDERS_PATH, \n",
    "                LAYER, K, \n",
    "                SKIP_SEQUENCES, TRAIN_SEQUENCES, VAL_SEQUENCES,\n",
    "                train=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "edge_attr torch.float64\n",
      "edge_index torch.int64\n",
      "x torch.float64\n",
      "y torch.float64\n",
      "Data(edge_attr=[7324], edge_index=[2, 7324], x=[128, 64], y=[128, 2])\n",
      "64\n",
      "128\n"
     ]
    }
   ],
   "source": [
    "data = train[0]\n",
    "for key, item in data:\n",
    "    print(key, item.dtype)\n",
    "\n",
    "print(data)\n",
    "print(data.num_features)\n",
    "print(data.num_nodes)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Simple GCN"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Net(torch.nn.Module):\n",
    "    def __init__(self, in_channels, out_channels):\n",
    "        super(Net, self).__init__()\n",
    "        \n",
    "        self.conv1 = GCNConv(in_channels, 128)\n",
    "        self.conv2 = GCNConv(128, 128)\n",
    "        \n",
    "        self.lin1 = nn.Linear(128, 64)\n",
    "        self.lin2 = nn.Linear(64, out_channels)\n",
    "\n",
    "    def forward(self, data):\n",
    "        x, edge_index, edge_attr = data.x, data.edge_index, data.edge_attr\n",
    "        \n",
    "        x = self.conv1(x, edge_index, edge_attr)\n",
    "        x = F.relu(x)\n",
    "        x = F.dropout(x, training=self.training)\n",
    "        \n",
    "        x = self.conv2(x, edge_index, edge_attr)\n",
    "        x = F.relu(x)\n",
    "        x = F.dropout(x, training=self.training)\n",
    "        \n",
    "        x = self.lin1(x)\n",
    "        x = F.relu(x)\n",
    "        x = F.dropout(x, training=self.training)\n",
    "        \n",
    "        x = self.lin2(x)\n",
    "        \n",
    "        return x       "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "def train_net(model, train_loader, optimizer, criterion, num_epochs=10, log_nth=10, verbose=True):\n",
    "\n",
    "    # prepare the net for training\n",
    "    model.train()\n",
    "    \n",
    "    train_loss_history = []\n",
    "    \n",
    "    if verbose: print('START TRAIN.')\n",
    "        \n",
    "    # loop over the dataset multiple times\n",
    "    for epoch in range(num_epochs):\n",
    "        running_loss = 0.0\n",
    "        # train on batches of data\n",
    "        for i, data in enumerate(train_loader):\n",
    "                      \n",
    "            data = data.to(device)\n",
    "\n",
    "            # zero the parameter gradients\n",
    "            optimizer.zero_grad()\n",
    "\n",
    "            # forward pass to get outputs\n",
    "            out = model(data)\n",
    "            \n",
    "            # calculate the loss between predicted and target keypoints\n",
    "            out_flatten = out.flatten()\n",
    "            y_flatten = data.y.flatten()\n",
    "            loss = criterion(out_flatten, y_flatten)\n",
    "\n",
    "            # backward pass to calculate the weight gradients\n",
    "            loss.backward()\n",
    "\n",
    "            # update the weights\n",
    "            optimizer.step()\n",
    "            \n",
    "            # store loss for each batch\n",
    "            train_loss_history.append(loss.data)\n",
    "            \n",
    "            # log the loss every log_nth iterations\n",
    "            running_loss += loss.item()\n",
    "            if i % log_nth == log_nth - 1:\n",
    "                if verbose:\n",
    "                    print('[%d, %5d] loss: %.5f' \n",
    "                          %(epoch + 1, i + 1, running_loss / log_nth))\n",
    "                running_loss = 0.0\n",
    "            \n",
    "    if verbose: print('FINISH.')\n",
    "    \n",
    "    return train_loss_history"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "def val_net(model, val_loader, criterion):\n",
    "    model.eval()\n",
    "    running_loss = 0.0\n",
    "    \n",
    "    for i, data in enumerate(val_loader):\n",
    "\n",
    "        data = data.to(device)\n",
    "\n",
    "        # forward pass to get outputs\n",
    "        with torch.no_grad():\n",
    "            out = model(data)\n",
    "\n",
    "        # calculate the loss between predicted and target keypoints\n",
    "        out_flatten = out.flatten()\n",
    "        y_flatten = data.y.flatten()\n",
    "        loss = criterion(out_flatten, y_flatten)\n",
    "\n",
    "        # log the loss every log_nth iterations\n",
    "        running_loss += loss.item()\n",
    "\n",
    "    metric = 1.0 / (2 * (running_loss/len(val_loader)))\n",
    "    print(\"Metric on VAL data: {}\".format(metric))\n",
    "    print('Finished Validation')\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Overfit"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Net(\n",
      "  (conv1): GCNConv(64, 128)\n",
      "  (conv2): GCNConv(128, 128)\n",
      "  (lin1): Linear(in_features=128, out_features=64, bias=True)\n",
      "  (lin2): Linear(in_features=64, out_features=2, bias=True)\n",
      ")\n"
     ]
    }
   ],
   "source": [
    "num_train = 1\n",
    "OverfitSampler = SequentialSampler(range(num_train))\n",
    "\n",
    "overfit_train_loader = DataLoader(train, batch_size=1, \n",
    "                                  shuffle=False, sampler=OverfitSampler)\n",
    "\n",
    "# Load model and run the solver\n",
    "overfit_model = Net(in_channels=train[0].num_features, \n",
    "                    out_channels=train[0].y.shape[1])\n",
    "print(overfit_model)\n",
    "overfit_model.double()\n",
    "overfit_model.to(device)\n",
    "criterion = nn.MSELoss()\n",
    "optimizer = optim.Adam(overfit_model.parameters(), lr=1e-4, betas=(0.9, 0.999), \n",
    "                       eps=1e-8, weight_decay=0.0)\n",
    "train_loss_history = train_net(overfit_model, overfit_train_loader, optimizer, criterion, \n",
    "                               num_epochs=250, verbose=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.plot(train_loss_history, 'o')\n",
    "plt.xlabel('iteration')\n",
    "plt.ylabel('loss')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "overfit_model.double()\n",
    "overfit_model.cpu()\n",
    "overfit_model.eval()\n",
    "\n",
    "image = cv2.imread('DAVIS_2016/DAVIS/Annotations/480p/bear/00001.png')\n",
    "sample = next(iter(overfit_train_loader))\n",
    "y = sample.y.detach().numpy()\n",
    "\n",
    "with torch.no_grad():\n",
    "    pred = overfit_model(sample).detach().numpy()\n",
    "\n",
    "contour = np.load('pg_datasets/DAVIS_2016/raw/Contours/bear/00000.npy')\n",
    "\n",
    "translation_ground_truth = contour + y\n",
    "translation_pred = contour + pred"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "def plot_translation(image, translation_ground_truth, translation_pred):\n",
    "    \n",
    "    fig, ax = plt.subplots(figsize=(15, 10))\n",
    "    \n",
    "    ax.scatter(translation_ground_truth[:, 0], translation_ground_truth[:, 1], color='g')\n",
    "    ax.scatter(translation_pred[:, 0], translation_pred[:, 1], color='r')\n",
    "    \n",
    "    # Plot image\n",
    "    ax.imshow(image)\n",
    "    \n",
    "    ax.axis('image')\n",
    "    ax.set_xticks([])\n",
    "    ax.set_yticks([])\n",
    "\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 1080x720 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "plot_translation(image, translation_ground_truth, translation_pred)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Train"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Net(\n",
      "  (conv1): GCNConv(64, 128)\n",
      "  (conv2): GCNConv(128, 128)\n",
      "  (lin1): Linear(in_features=128, out_features=64, bias=True)\n",
      "  (lin2): Linear(in_features=64, out_features=2, bias=True)\n",
      ")\n",
      "START TRAIN.\n",
      "[1,    10] loss: 1190.67027\n",
      "[1,    20] loss: 754.95022\n",
      "[1,    30] loss: 774.08713\n",
      "[1,    40] loss: 367.47669\n",
      "[1,    50] loss: 359.63690\n",
      "[1,    60] loss: 462.30182\n",
      "[1,    70] loss: 245.87975\n",
      "[1,    80] loss: 423.69183\n",
      "[1,    90] loss: 261.26376\n",
      "[1,   100] loss: 330.53207\n",
      "[1,   110] loss: 1276.93699\n",
      "[1,   120] loss: 335.40801\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/anaconda3/lib/python3.7/site-packages/torch/nn/modules/loss.py:443: UserWarning: Using a target size (torch.Size([146])) that is different to the input size (torch.Size([254])). This will likely lead to incorrect results due to broadcasting. Please ensure they have the same size.\n",
      "  return F.mse_loss(input, target, reduction=self.reduction)\n"
     ]
    },
    {
     "ename": "RuntimeError",
     "evalue": "The size of tensor a (254) must match the size of tensor b (146) at non-singleton dimension 0",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mRuntimeError\u001b[0m                              Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-23-d019b65a782e>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m     10\u001b[0m optimizer = optim.Adam(model.parameters(), lr=1e-4, betas=(0.9, 0.999), \n\u001b[1;32m     11\u001b[0m                        eps=1e-8, weight_decay=0.0)\n\u001b[0;32m---> 12\u001b[0;31m \u001b[0mtrain_loss_history\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mtrain_net\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mmodel\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtrain_loader\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0moptimizer\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcriterion\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[0;32m<ipython-input-18-74863d80b14e>\u001b[0m in \u001b[0;36mtrain_net\u001b[0;34m(model, train_loader, optimizer, criterion, num_epochs, log_nth, verbose)\u001b[0m\n\u001b[1;32m     25\u001b[0m             \u001b[0mout_flatten\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mout\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mflatten\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     26\u001b[0m             \u001b[0my_flatten\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0my\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mflatten\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 27\u001b[0;31m             \u001b[0mloss\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mcriterion\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mout_flatten\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my_flatten\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     28\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     29\u001b[0m             \u001b[0;31m# backward pass to calculate the weight gradients\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/opt/anaconda3/lib/python3.7/site-packages/torch/nn/modules/module.py\u001b[0m in \u001b[0;36m__call__\u001b[0;34m(self, *input, **kwargs)\u001b[0m\n\u001b[1;32m    491\u001b[0m             \u001b[0mresult\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_slow_forward\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0minput\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    492\u001b[0m         \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 493\u001b[0;31m             \u001b[0mresult\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mforward\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0minput\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    494\u001b[0m         \u001b[0;32mfor\u001b[0m \u001b[0mhook\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_forward_hooks\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mvalues\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    495\u001b[0m             \u001b[0mhook_result\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mhook\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0minput\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mresult\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/opt/anaconda3/lib/python3.7/site-packages/torch/nn/modules/loss.py\u001b[0m in \u001b[0;36mforward\u001b[0;34m(self, input, target)\u001b[0m\n\u001b[1;32m    441\u001b[0m     \u001b[0;34m@\u001b[0m\u001b[0mweak_script_method\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    442\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0mforward\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0minput\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtarget\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 443\u001b[0;31m         \u001b[0;32mreturn\u001b[0m \u001b[0mF\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmse_loss\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minput\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtarget\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mreduction\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mreduction\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    444\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    445\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/opt/anaconda3/lib/python3.7/site-packages/torch/nn/functional.py\u001b[0m in \u001b[0;36mmse_loss\u001b[0;34m(input, target, size_average, reduce, reduction)\u001b[0m\n\u001b[1;32m   2254\u001b[0m             \u001b[0mret\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mtorch\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmean\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mret\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mif\u001b[0m \u001b[0mreduction\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0;34m'mean'\u001b[0m \u001b[0;32melse\u001b[0m \u001b[0mtorch\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msum\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mret\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   2255\u001b[0m     \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 2256\u001b[0;31m         \u001b[0mexpanded_input\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mexpanded_target\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mtorch\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbroadcast_tensors\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minput\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtarget\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   2257\u001b[0m         \u001b[0mret\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mtorch\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_C\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_nn\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmse_loss\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mexpanded_input\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mexpanded_target\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0m_Reduction\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mget_enum\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mreduction\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   2258\u001b[0m     \u001b[0;32mreturn\u001b[0m \u001b[0mret\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/opt/anaconda3/lib/python3.7/site-packages/torch/functional.py\u001b[0m in \u001b[0;36mbroadcast_tensors\u001b[0;34m(*tensors)\u001b[0m\n\u001b[1;32m     60\u001b[0m                 [0, 1, 2]])\n\u001b[1;32m     61\u001b[0m     \"\"\"\n\u001b[0;32m---> 62\u001b[0;31m     \u001b[0;32mreturn\u001b[0m \u001b[0mtorch\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_C\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_VariableFunctions\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbroadcast_tensors\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtensors\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     63\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     64\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mRuntimeError\u001b[0m: The size of tensor a (254) must match the size of tensor b (146) at non-singleton dimension 0"
     ]
    }
   ],
   "source": [
    "train_loader = DataLoader(train, batch_size=BATCH_SIZE, shuffle=True)\n",
    "\n",
    "# Load model and run the solver\n",
    "model = Net(in_channels=train[0].num_features, \n",
    "            out_channels=train[0].y.shape[1])\n",
    "print(model)\n",
    "model.double()\n",
    "model.to(device)\n",
    "criterion = nn.MSELoss()\n",
    "optimizer = optim.Adam(model.parameters(), lr=1e-4, betas=(0.9, 0.999), \n",
    "                       eps=1e-8, weight_decay=0.0)\n",
    "train_loss_history = train_net(model, train_loader, optimizer, criterion)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.plot(train_loss_history, 'o')\n",
    "plt.xlabel('iteration')\n",
    "plt.ylabel('loss')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Validate"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "train_loader = DataLoader(train, batch_size=BATCH_SIZE, \n",
    "                          shuffle=True, sampler=OverfitSampler)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n",
    "model = Net().to(device)\n",
    "data = dataset[0].to(device)\n",
    "optimizer = torch.optim.Adam(model.parameters(), lr=0.01, weight_decay=5e-4)\n",
    "\n",
    "model.train()\n",
    "for epoch in range(200):\n",
    "    optimizer.zero_grad()\n",
    "    out = model(data)\n",
    "    loss = F.nll_loss(out[data.train_mask], data.y[data.train_mask])\n",
    "    loss.backward()\n",
    "    optimizer.step()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
